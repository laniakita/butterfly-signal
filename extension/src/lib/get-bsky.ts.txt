import { agent } from './api';
import { CONFIG  } from './config';
import { getCurrentTab, getChromeKV, setChromeKV, updateIcon } from './chrome-utils';

async function getDomain(url: string) {
	try {
		if (CONFIG.DEBUG) console.log(`[info]: attempting to get hostname from ${url}`);
		if (!url) throw new Error();
		const newUrl = new URL(url);

		const host = newUrl.hostname;

		if (CONFIG.DEBUG) console.log(`[success]: found ${host}`);

		return host;
	} catch (err) {
		console.error('[error]: hostname extraction failed: ', err);
	}
}

async function getAtProtoRecord(hostname: string) {
	if (CONFIG.DEBUG) console.log(`[info]: searching for TXT record on _atproto.${hostname}`);
	try {
		const fetchTxtRes = fetch(
			`https://cloudflare-dns.com/dns-query?name=_atproto.${hostname}&type=TXT`,
			{
				headers: {
					accept: 'application/dns-json'
				}
			}
		).then((res) => res.json());
		return fetchTxtRes;
	} catch (err) {
		console.warn('[warn]: failed to get TXT record', err);
	}
}

async function getBskyLink(hostname: string) {
	const atProtoRecRes = await getAtProtoRecord(hostname);
	if (atProtoRecRes) {
		if (atProtoRecRes.Answer) {
			const recName = atProtoRecRes.Answer[0].name;
			if (recName) {
				if (CONFIG.DEBUG) console.log(`[success]: found TXT record for _atproto.${hostname}`);
				const bskyLink = `https://bsky.app/profile/${hostname}`;
				if (CONFIG.DEBUG) console.log(`[success]: generated url: ${bskyLink}`);
				return bskyLink;
			}
		}
	}

	if (CONFIG.DEBUG) console.warn(`[warn]: could not find a TXT record for _atproto.${hostname}`);

	return undefined;
}

interface MiniProfile {
	handle: string | null;
	displayName: string | null;
	description: string | null;
	avatar: string | null;
	banner: string | null;
}

export interface BskyData extends MiniProfile {
	link: string | null;
	updated: Date;
}

async function fetchProfile(handle: string): Promise<MiniProfile | undefined> {
	if (CONFIG.DEBUG) console.log('[info]: attempting to fetch profile via AtProto');
	try {
		const res = await agent.app.bsky.actor.getProfile({ actor: handle });
		const data: MiniProfile = res?.data && {
			handle: res.data.handle ?? null,
			displayName: res.data.displayName ?? null,
			description: res.data.description ?? null,
			avatar: res.data.avatar ?? null,
			banner: res.data.banner ?? null
		};
		if (CONFIG.DEBUG) {
			console.log(`[success]: fetched ${data.displayName}'s profile`);
			console.log(`====== begin profile ======`);
			console.dir(data, { depth: null });
			console.log(`======= end profile =======`);
		}

		return data;
	} catch (err) {
		console.warn("[warn]: couldn't fetch profile", err);
	}
}

async function updateBskyInfo(hostname: string): Promise<BskyData> {
	if (CONFIG.DEBUG) console.log('[info]: attempting to update BskyData on', hostname);

	const bskyLinkRes = await getBskyLink(hostname);

	/**
	 *  If bskyLinkRes returns a bluesky link (string),
	 *  we can use the hostname as the handle, and fetch
	 *  profile data via the atproto/api
	 */
	if (bskyLinkRes) {
		const profile = await fetchProfile(hostname);
		if (profile) {
			const bskyData: BskyData = {
				...profile,
				link: bskyLinkRes,
				updated: new Date()
			};
			await setChromeKV(hostname, JSON.stringify(bskyData));
			return bskyData;
		}
	}

	const nullBskyData: BskyData = {
		handle: null,
		displayName: null,
		description: null,
		avatar: null,
		banner: null,
		link: null,
		updated: new Date()
	};

	await setChromeKV(hostname, JSON.stringify(nullBskyData));
	return nullBskyData;
}

export async function getBskyInfo(): Promise<BskyData | undefined> {
	const tabRes = await getCurrentTab();
	if (CONFIG.DEBUG) console.log('[info]: searching for url in active tab');
	if (tabRes && tabRes[0]) {
		if ('url' in tabRes[0]) {
			if (tabRes[0].url) {
				if (CONFIG.DEBUG) console.log(`[success]: found ${tabRes[0].url}`);
				const hostnameRes = await getDomain(tabRes[0].url);
				// splitting the hostname ensures new tabs exit the logic chain here
				if (hostnameRes && hostnameRes.split('.').length > 1) {
					const re = /^www\./;
					const cleanHostname = hostnameRes.replace(re, '');

					// check if the current hostname has been seen before
					const cachedBsky = (await getChromeKV(cleanHostname)) as unknown as string;

					if (cachedBsky && cachedBsky.length > 3) {
						const data = JSON.parse(cachedBsky) as BskyData;

						if (CONFIG.DEBUG) console.log('[info]: found cached data for', cleanHostname);
						/*
						 *  We can return the cached data outright given it's not stale,
						 *  otherwise if it is, we can revalidate it, before returning
						 *  an updated instance of BskyData
						 **/

						const revalidationTime = CONFIG.REVALIDATE; // 86400;

						let tDelta = 0;

						if ('updated' in data) {
							const t0 = new Date(data.updated);
							const t1 = Date.now();
							tDelta = (t1 - t0.getTime()) / 1000;

							if (CONFIG.DEBUG)
								console.log(`[info]: cached data has a time delta of ${tDelta} seconds`);
						}

						if (tDelta > 0 && tDelta < revalidationTime) {
							if (CONFIG.DEBUG)
								console.log(
									`[info]: ${tDelta} < ${revalidationTime} -> data not stale -> returning cached data \n\n`,
									data
								);
							return data;
						} else {
							/*
							 *  Since the data is stale, we'll revalidate it
							 **/

							if (CONFIG.DEBUG)
								console.log(
									`[info]: ${tDelta} > ${revalidationTime} -> data stale -> revalidating`
								);
							const updateRes = await updateBskyInfo(cleanHostname);
							return updateRes;
						}
					} else {
						if (CONFIG.DEBUG) console.log(`[info]: cache not found for ${cleanHostname} ... first time, huh? ;)`);
						
						const newRes = await updateBskyInfo(cleanHostname);
						return newRes;

					}
				}
				if (CONFIG.DEBUG) console.log(`[success]: found internal chrome page! exiting ...`)
			}
		} else {
			if (CONFIG.DEBUG) console.warn('[warn]: no url found in active tab');
		}
	}

	return undefined;
}


export async function handleUpdate(): Promise<BskyData | undefined> {
	if (CONFIG.DEBUG) console.log('[info]: attempting update');

	const bskyRes = await getBskyInfo();

	if (bskyRes) {
		if (bskyRes.handle !== null) {
			updateIcon({ isActive: true });
			if (CONFIG.DEBUG) console.log('[success]: BskyData update complete');
			return bskyRes;
		}
	}

	if (CONFIG.DEBUG) console.log('[info]: no bluesky data found');
	updateIcon({ isActive: false });
	if (CONFIG.DEBUG) console.log('[success]: null update complete');
	return undefined;
}
